class HT16K33MATRIX
{
	// Squirrel class for 1.2-inch 8x8 LED matrix displays driven by the HT16K33 controller
	// For example: http://www.adafruit.com/products/1854
	// Communicates with any imp I2C bus
 
	// Availibility: Device

	// Written by Tony Smith (@smittytone) October 2014
	// Version 1.0
	// Copyright 2014 Electric Imp
	// Issued under the MIT license (MIT)

	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	// 	The above copyright notice and this permission notice shall be included in
	// 	all copies or substantial portions of the Software.

	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	
	// HT16K33 registers and HT16K33-specific variables

	HT16K33_REGISTER_DISPLAY_ON  = "\x81"
	HT16K33_REGISTER_DISPLAY_OFF = "\x80"
	HT16K33_REGISTER_SYSTEM_ON   = "\x21"
	HT16K33_REGISTER_SYSTEM_OFF  = "\x20"
	HT16K33_DISPLAY_ADDRESS      = "\x00"
	HT16K33_I2C_ADDRESS = 0x70

	charset = [
	[0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0],			// Space - Ascii 32
	[0x0,0x10,0x10,0x10,0x10,0x0,0x10,0x0],		// !
	[0x0,0x24,0x24,0x0,0x0,0x0,0x0,0x0],		// ”
	[0x0,0x24,0x7E,0x24,0x24,0x7E,0x24,0x0],	// #
	[0x0,0x8,0x3E,0x28,0x3E,0xA,0x3E,0x8],		// $
	[0x0,0x62,0x64,0x8,0x10,0x26,0x46,0x0],		// %
	[0x0,0x10,0x28,0x10,0x2A,0x44,0x3A,0x0],	// &
	[0x0,0x8,0x10,0x0,0x0,0x0,0x0,0x0],			// ‘
	[0x0,0x4,0x8,0x8,0x8,0x8,0x4,0x0],			// (
	[0x0,0x20,0x10,0x10,0x10,0x10,0x20,0x0],	// )
	[0x0,0x0,0x14,0x8,0x3E,0x8,0x14,0x0],		// *
	[0x0,0x0,0x8,0x8,0x3E,0x8,0x8,0x0],			// +
	[0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x10],			// ,
	[0x0,0x0,0x0,0x0,0x3E,0x0,0x0,0x0],			// -
	[0x0,0x0,0x0,0x0,0x0,0x18,0x18,0x0],		// .
	[0x0,0x2,0x4,0x8,0x10,0x20,0x40,0x0],		// /
	[0x0,0x3C,0x46,0x4A,0x52,0x62,0x3C,0x0],	// 0 - Ascii 48
	[0x0,0x30,0x50,0x10,0x10,0x10,0x7C,0x0],	// 1
	[0x0,0x3C,0x42,0x2,0x3C,0x40,0x7E,0x0],		// 2
	[0x0,0x3C,0x42,0xC,0x2,0x42,0x3C,0x0],		// 3
	[0x0,0x8,0x18,0x28,0x48,0x7E,0x8,0x0],		// 4
	[0x0,0x7E,0x40,0x7C,0x2,0x42,0x3C,0x0],		// 5
	[0x0,0x3C,0x40,0x7C,0x42,0x42,0x3C,0x0],	// 6
	[0x0,0x7E,0x2,0x4,0x8,0x10,0x10,0x0],		// 7
	[0x0,0x3C,0x42,0x3C,0x42,0x42,0x3C,0x0],	// 8
	[0x0,0x3C,0x42,0x42,0x3E,0x2,0x3C,0x0],		// 9
	[0x0,0x0,0x10,0x0,0x0,0x0,0x10,0x0],		// : - Ascii 58
	[0x0,0x0,0x10,0x0,0x0,0x10,0x10,0x20],		//
	[0x0,0x0,0x4,0x8,0x10,0x8,0x4,0x0],			// <
	[0x0,0x0,0x0,0x3E,0x0,0x3E,0x0,0x0],		// =
	[0x0,0x0,0x10,0x8,0x4,0x8,0x10,0x0],		// >
	[0x0,0x3C,0x42,0x4,0x8,0x0,0x8,0x0],		// ?
	[0x0,0x3C,0x4A,0x56,0x5E,0x40,0x3C,0x0],	// @
	[0x0,0x3C,0x42,0x42,0x7E,0x42,0x42,0x0],	// A - Ascii 65
	[0x0,0x7C,0x42,0x7C,0x42,0x42,0x7C,0x0],	// B
	[0x0,0x3C,0x42,0x40,0x40,0x42,0x3C,0x0],	// C
	[0x0,0x78,0x44,0x42,0x42,0x44,0x78,0x0],	// D
	[0x0,0x7E,0x40,0x7C,0x40,0x40,0x7E,0x0],	// E
	[0x0,0x7E,0x40,0x7C,0x40,0x40,0x40,0x0],	// F
	[0x0,0x3C,0x42,0x40,0x4E,0x42,0x3C,0x0],	// G
	[0x0,0x42,0x42,0x7E,0x42,0x42,0x42,0x0],	// H
	[0x0,0x7C,0x10,0x10,0x10,0x10,0x7C,0x0],	// I
	[0x0,0x2,0x2,0x2,0x2,0x42,0x3C,0x0],		// J
	[0x0,0x44,0x48,0x70,0x48,0x44,0x42,0x0],	// K
	[0x0,0x40,0x40,0x40,0x40,0x40,0x7E,0x0],	// L
	[0x0,0x42,0x66,0x5A,0x42,0x42,0x42,0x0],	// M
	[0x0,0x42,0x62,0x52,0x4A,0x46,0x42,0x0],	// N
	[0x0,0x3C,0x42,0x42,0x42,0x42,0x3C,0x0],	// O
	[0x0,0x7C,0x42,0x42,0x7C,0x40,0x40,0x0],	// P
	[0x0,0x3C,0x42,0x42,0x52,0x4A,0x3C,0x0],	// Q
	[0x0,0x7C,0x42,0x42,0x7C,0x44,0x42,0x0],	// R
	[0x0,0x3C,0x40,0x3C,0x2,0x42,0x3C,0x0],		// S
	[0x0,0x7C,0x10,0x10,0x10,0x10,0x10,0x0],	// T
	[0x0,0x42,0x42,0x42,0x42,0x42,0x3C,0x0],	// U
	[0x0,0x42,0x42,0x42,0x42,0x24,0x18,0x0],	// V
	[0x0,0x42,0x42,0x42,0x42,0x5A,0x24,0x0],	// W
	[0x0,0x42,0x24,0x18,0x18,0x24,0x42,0x0],	// X
	[0x0,0x44,0x28,0x10,0x10,0x10,0x10,0x0],	// Y
	[0x0,0x7E,0x4,0x8,0x10,0x20,0x7E,0x0],		// Z - Ascii 90
	[0x0,0xE,0x8,0x8,0x8,0x8,0xE,0x0],		    // [
	[0x0,0x0,0x40,0x20,0x10,0x8,0x4,0x0],		// \
	[0x0,0x70,0x10,0x10,0x10,0x10,0x70,0x0],	// ]
	[0x0,0x10,0x38,0x54,0x10,0x10,0x10,0x0],	// ^
	[0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xFF],		    // _
	[0x0,0x1C,0x22,0x78,0x20,0x20,0x7E,0x0],	// £
	[0x0,0x0,0x38,0x4,0x3C,0x44,0x3C,0x0],		// a - Ascii 97
	[0x0,0x40,0x40,0x78,0x44,0x44,0x78,0x0],	// b
	[0x0,0x0,0x38,0x40,0x40,0x40,0x38,0x0],		// c
	[0x0,0x4,0x4,0x3C,0x44,0x44,0x3C,0x0],		// d
	[0x0,0x0,0x38,0x44,0x78,0x40,0x3C,0x0],		// e
	[0x0,0x30,0x40,0x60,0x40,0x40,0x40,0x0],	// f
	[0x0,0x3C,0x44,0x44,0x3C,0x4,0x38,0x0],		// g
	[0x0,0x40,0x40,0x40,0x78,0x44,0x44,0x0],	// h
	[0x0,0x20,0x0,0x60,0x20,0x20,0x70,0x0],		// i
	[0x0,0x8,0x0,0x8,0x8,0x48,0x30,0x0],		// j
	[0x0,0x40,0x50,0x60,0x60,0x50,0x48,0x0],	// k
	[0x0,0x40,0x40,0x40,0x40,0x40,0x30,0x0],	// l
	[0x0,0x0,0x68,0x54,0x54,0x54,0x54,0x0],		// m
	[0x0,0x0,0x78,0x44,0x44,0x44,0x44,0x0],    	// n
	[0x0,0x0,0x38,0x44,0x44,0x44,0x38,0x0],		// o
	[0x0,0x78,0x44,0x44,0x78,0x40,0x40,0x0],	// p
	[0x0,0x3C,0x44,0x44,0x3C,0x4,0x6,0x0],		// q
	[0x0,0x0,0x1C,0x20,0x20,0x20,0x20,0x0],	   	// r
	[0x0,0x0,0x38,0x40,0x38,0x4,0x78,0x0],		// s
	[0x0,0x20,0x70,0x20,0x20,0x20,0x18,0x0],	// t
	[0x0,0x0,0x44,0x44,0x44,0x44,0x38,0x0],		// u
	[0x0,0x0,0x44,0x44,0x28,0x28,0x10,0x0],		// v
	[0x0,0x0,0x44,0x54,0x54,0x54,0x28,0x0],		// w
	[0x0,0x0,0x44,0x28,0x10,0x28,0x44,0x0],		// x
	[0x0,0x0,0x44,0x44,0x3C,0x4,0x38,0x0],		// y
	[0x0,0x0,0x7C,0x8,0x10,0x20,0x7C,0x0],		// z - Ascii 122
	[0x0,0xE,0x8,0x30,0x8,0x8,0xE,0x0],			// {
	[0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x0],			// |
	[0x0,0x70,0x10,0xC,0x10,0x10,0x70,0x0],		// }
	[0x0,0x14,0x28,0x0,0x0,0x0,0x0,0x0],		// ~
	[0x3C,0x42,0x99,0xA1,0xA1,0x99,0x42,0x3C],	// © - Ascii 127
	[0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF],	// Block Graphic 1
	[0xF,0xF,0xF,0xF,0xFF,0xFF,0xFF,0xFF],
	[0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF],
	[0x0,0x0,0x0,0x0,0xFF,0xFF,0xFF,0xFF],
	[0xFF,0xFF,0xFF,0xFF,0xF,0xF,0xF,0xF],
	[0xF,0xF,0xF,0xF,0xF,0xF,0xF,0xF],
	[0xF0,0xF0,0xF0,0xF0,0xF,0xF,0xF,0xF],
	[0x0,0x0,0x0,0x0,0xF,0xF,0xF,0xF],
	[0xFF,0xFF,0xFF,0xFF,0x55,0xAA,0x55,0xAA],
	[0xAA,0x55,0xAA,0x55,0xFF,0xFF,0xFF,0xFF],
	[0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55],	// Block Graphic 11
	]

	// Class private properties. Those defined in the Constructor should be null

	_buffer = null
	_led = null
	_ledAddress = 0
	_alphaCount = 107
	_rotationAngle = 0
	
	// Public properties
	
	rotateFlag = false
    inverseVideoFlag = false
    
	constructor(impI2Cbus, ht16k33Address = 0x70)
	{
		// Parameters:
		// 1. Whichever imp I2C bus is to be used for the HT16K33
		// 2. The HT16K33's I2C address (default: 0x70)

		_led = impI2Cbus
		_ledAddress = ht16k33Address << 1

		// Buffer stores the character matrix values for each row of the display

		_buffer = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    }

	function init(brightness = 15, rotate = false, angle = 0)
	{
		_rotationAngle = angle
		rotateFlag = rotate
		
		// Configure the I2C bus

		_led.configure(CLOCK_SPEED_100_KHZ)

		// Set the brightness (which of necessity wipes and power cyles the dispay)

		setBrightness(brightness)
	}

	function setBrightness(brightness = 15)
	{
		// Called when the app changes the brightness
		// Default: 15

		if (brightness > 15) brightness = 15
		if (brightness < 0) brightness = 0

		brightness = brightness + 224

		// Wipe the display completely first, so preserve what's in the _buffer

		local sbuffer = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

		for (local i = 0 ; i < 8 ; i++)
		{
		    sbuffer[i] = _buffer[i]
		}

		// Clear the LED matrix
		
		clearDisplay()

		// Power cycle the LED matrix

		powerDown()
		powerUp()

        // Write the new brightness value to the HT16K33

		_led.write(_ledAddress, brightness.tochar() + "\x00")

		// Restore what's was in the _buffer...
		
        for (local i = 0 ; i < 8 ; i++)
		{
		    _buffer[i] = sbuffer[i]
		}

		// ... and write it back to the LED matrix

        writeDisplay()
	}

	function powerDown()
	{
		_led.write(_ledAddress, HT16K33_REGISTER_DISPLAY_OFF)
		_led.write(_ledAddress, HT16K33_REGISTER_SYSTEM_OFF)
	}

	function powerUp()
	{
		_led.write(_ledAddress, HT16K33_REGISTER_SYSTEM_ON)
		_led.write(_ledAddress, HT16K33_REGISTER_DISPLAY_ON)
	}
	
	function writeDisplay()
	{
		// Takes the contents of _buffer and writes it to the LED matrix
		// Uses function processByte() to manipulate regular values to 
		// Adafruit 8x8 matrix's format
		
		local dataString = HT16K33_DISPLAY_ADDRESS

		for (local i = 0 ; i < 8 ; i++)
		{
			dataString = dataString + (processByte(_buffer[i])).tochar() + "\x00"
		}

		_led.write(_ledAddress, dataString)
	}

	function clearDisplay()
	{
		// Clears the _buffer, which is then written to the LED matrix
		
		_buffer = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
		writeDisplay()
	}

	function displayIcon(inputMatrix = [0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF])
	{
		// Parameters:
		// 1. Array of 8 8-bit values defining a pixel image
		
		if (rotateFlag) inputMatrix = rotateMatrix(inputMatrix, _rotationAngle)

		for (local i = 0 ; i < 8 ; i++)
		{
			if (inverseVideoFlag)
			{
				_buffer[i] = ~inputMatrix[i]
			}
			else
			{
				_buffer[i] = inputMatrix[i]
			}
		}

		writeDisplay()
	}

	function displayChar(asciiValue = 32)
	{
		asciiValue = asciiValue - 32
		if (asciiValue < 0 || asciiValue > _alphaCount) asciiValue = 0

		local inputMatrix = clone(charset[asciiValue])
		if (rotateFlag) inputMatrix = rotateMatrix(inputMatrix, _rotationAngle)

		for (local i = 0 ; i < 8 ; i++)
		{
			if (inverseVideoFlag == 1)
			{
				_buffer[i] = ~inputMatrix[i]
			}
			else
			{
				_buffer[i] = inputMatrix[i]
			}
		}

		writeDisplay()
	}

	function displayLine(line = "The quick brown fox jumps over the lazy dog")
	{
		// Bit-scroll through the characters in the variable ‘line’

		local a = 0
		local b = 0
		local count = 0
		local outputMatrix = [0,0,0,0,0,0,0,0]
		local matrixOne = [0,0,0,0,0,0,0,0]
		local matrixTwo = [0,0,0,0,0,0,0,0]

		count = line.len()

		if (count == 1)
		{
			count = 2
			line = " " + line
		}

		for (local k = 0 ; k < (count - 1) ; k++)
		{
			// Run through the line character by character up to the penultimate character

			// Get the current character to be displayed and the next character along by
			// copying them from the character set array

			a = line[k]
			b = line[k + 1]

			matrixOne = clone(charset[a - 32])
			matrixTwo = clone(charset[b - 32])

			for (local j = 0 ; j < 8 ; j++)
			{
				// We use two character matrices, one on the left and one on the right.
				// Line by line, we shift the left matrix's bit pattern one bit at a time.
				// If the seventh bit of a line in the right-hand matrix is set,
				// we then set bit 0 of the left-hand matrix.
				// We then shift the right-hand matrix leftward one bit.

				outputMatrix = matrixOne
				
				if (rotateFlag) outputMatrix = rotateMatrix(outputMatrix, _rotationAngle)

				for (local i = 0 ; i < 8 ; i++)
				{
					// Write the current character’s matrix

					if (inverseVideoFlag)
					{
						_buffer[i] = ~outputMatrix[i]
					}
					else
					{
						_buffer[i] = outputMatrix[i]
					}

					// Use the Logical Shift Left operator to move the line one pixel

					matrixOne[i] = matrixOne[i] << 1

					// Move over second matrix by one pixel

					if ((matrixTwo[i] & 128) > 0)
					{
						// If bit 7 of the right-hand character’s line is set,
						// carry it over to bit 0 of the left-hand character

						matrixOne[i] = matrixOne[i] | (1 << 0)
					}

					// Shift right-hand character line left one pixel

					matrixTwo[i] = (matrixTwo[i] << 1)
				}

				imp.sleep(0.04)
				writeDisplay()
			}
		}

		// For the final character, we need to perform a last pixel shift to leave
		// the character completely on the display

		outputMatrix = matrixOne
		if (rotateFlag) outputMatrix = rotateMatrix(outputMatrix, _rotationAngle)

		for (local i = 0 ; i < 8 ; i++)
		{
			if (inverseVideoFlag)
			{
				_buffer[i] = ~outputMatrix[i]
			}
			else
			{
				_buffer[i] = outputMatrix[i]
			}

			matrixOne[i] = matrixOne[i] << 1

			if ((matrixTwo[i] & 128) > 0) matrixOne[i] = matrixOne[i] | (1 << 0)
			matrixTwo[i] = (matrixTwo[i] << 1)
		}

		imp.sleep(0.04)
		writeDisplay()
	}

	function rotateMatrix(inputMatrix, angle = 0)
	{
		// Value of angle determines the rotation:
		// 0 = none, 1 = 90 clockwise, 2 = 180, 3 = 90 anti-clockwise
		
		if (angle < 1 || angle > 3) return inputMatrix

    	// Rotate the character matrix through 90 degrees

		local a = 0
		local lineValue = 0
		local outputMatrix = [0,0,0,0,0,0,0,0]
		
		for (local i = 0 ; i < angle ; i++)
		{
			outputMatrix = [0,0,0,0,0,0,0,0]
			
			for (local j = 0 ; j < 8 ; j++)
			{
				lineValue = inputMatrix[j]

				for (local k = 7 ; k > -1 ; k--)
				{
					a = (lineValue & math.pow(2, k).tointeger())
					if (a > 0) outputMatrix[7 - k] = outputMatrix[7 - k] + math.pow(2, j).tointeger()
				}
			}
			
			inputMatrix = outputMatrix
		}

		return outputMatrix
	}
	
	function processByte(byteValue)
	{
		// Adafruit 8x8 matrix requires some data manipulation:
		// Bits 7-0 of each line need to be sent 0 through 7, 
		// and bit 0 rotate to bit 7
		
		local result = 0
		local a = 0
		
		for (local i = 0 ; i < 8 ; i++)
		{
			// Run through each bit in byteValue and set the 
			// opposite bit in result accordingly, ie. bit 0 -> bit 7,
			// bit 1 -> bit 6, etc.
			
			a = byteValue & math.pow(2, i).tointeger()
			if (a > 0) result = result + math.pow(2, 7 - i).tointeger()
		}
		
		// Get bit 0 of result
		
		result & math.pow(2, 0).tointeger()
		
		// Shift result bits one bit to right
		
		result = result >> 1
		
		// if old bit 0 is set, set new bit 7
		
		if (a > 0) result = result + 0x80
		
		return result
	}
}
